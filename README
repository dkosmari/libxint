.-------------------------------------------------------------.
| libxint - a C++ library for extended size unsigned integers |
`-------------------------------------------------------------'

This is a headers-only C++20 library to emulate large fixed-size integers.
It's licensed under the GPLv3+ license.


,-------------
| Installation
`-------------

When checking out the source from the repository, first run:

  ./bootstrap

This step is not necessary when the source was obtained from the tarball.


Then run:

  ./configure
  make
  sudo make install


To uninstall:

  sudo make uninstall


This is a standard Automake package; run `./configure --help` or check `INSTALL` for
more details.


,------
| Usage
`------

First, include the header `libxint/uint.hpp` in your program.
The type `xint::uint<B>` is now available; the template argument `B` is the number
of desired bits. It can be used as any ordinary unsigned integer:

    #include <iostream>
    #include <libxint/uint.hpp>

    using namespace std;

    int main()
    {
        xint::uint<1024> x = 42;
        cout << x << endl;
        x <<= 1000;
        cout << x << endl;
        ++x;
        cout << x << endl;
        cout << popcount(x) << endl;
    }


,-----------------------
| Implementation details
`-----------------------

This extended integer is implemented through multiple native integers, called limbs.
The size of each limb can be controlled by defining the `XINT_LIMB_SIZE` macro. Valid
sizes are 8, 16 and 32 (which is the default.) For instance:

    g++ -std=c++20 -DXINT_LIMB_SIZE=16 my-program.cpp

The limbs can be accessed directly through the `limbs` member.

NOTE: do not specify a number of bits that's not a multiple of the limb size. Examples
of invalid sizes are:

    `uint<31>`
    `uint<16>` when `XINT_LIMB_SIZE=32`

No attempt is made to mask out the "excess" bits (for performance reasons) so the results
of all operations will be inconsistent.

